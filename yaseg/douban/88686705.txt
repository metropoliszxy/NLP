WINDOWS核心编程-第一部分：笔记

说明：该书中用到了 PlatForm SDK 里面的函数，想要正确运行代码，如果使用 VC 6.0，需安装 PlatForm SDK ，或者直接使用 VC.Net。 --------------------------------------------------------------- Soundboy的这个答案不是很正确，一般来说，应该使用PlatformSDK，然后在Tool -> Option里面设置Include的目录为SDK的Include目录，再Rebuild all，就可以了。1.windows 函数错误处理器线程本地存储器(thread-local storage )机制，能够将相应的错误代码号与调用的线程关联起来，这将使线程能够互相独立地运行，而不会影响各自的错误代码。DWORD GetLastError();当Windows函数运行失败时，应该立即调用GetLastError函数。如果调用另一个Windows函数，它的值很可能被改写。在Microsoft Visual studio 6.0中,通过选定Watch窗口中的一行，并键入“@err, hr”，就能显示线程的最后错误代码的号码和该错误的英文描述。另外，使用：工具->Error Lookup，可以将错误代码的号码转换成相应文本描述。在代码中，则可以利用FormatMessage函数将错误代码转换成它的文本描述。VOID SetLastError(DWORD dwErrCode);调用SetLastError函数可以设置用户定义的错误代码。--------2.UnicodeWindows 98不是一种全新的操作系统。它继承了16 位Windows操作系统的特性，仅支持ANSI。Windows 2000是使用Unicode从头进行开发的，所有非Unicode字符应用程序均需转换，而这是由系统自动完成的。Windows CE本身就是使用Unicode的一种操作系统，并且完全不支持ANSI Windows函数。当Microsoft公司将COM从16位Microsoft转换成Win32时,需要字符串的所有COM接口方法都只能接受Unicode字符串。2.1 C运行期库对Unicode的支持为了利用Unicode字符串，标准的C头文件String.h已经作了修改，以便定义一个名字为wchar_t的数据类型存储Unicode字符：typedef unsigned short wchar_t；所有的Unicode函数均以wcs开头，如下：char * strcat(char *,const char *);wchar_t * wcscat(wchar_t *,const wchar_t *);Microsoft公司提供的C运行期库与ANSI的标准C运行期库是一致的，所以，Windows 98也能很好的使用这些Unicode函数。TChar.h 头文件的唯一作用是帮助创建ANSI/Unicode通用源代码文件。它包含你应该用在源代码中的一组宏，而不应该直接调用str函数或者wcs函数。如果在编译源代码文件时定义了_UNICODE，这些宏就会引用wcs 这组函数。如果没有定义_UNICODE， ，那么这些宏将引用str这组宏。Microsoft公司的C++编译器，在字符串（literal string）前面加大写字母L ，用于告诉编译器该字符串应该作为Unicode字符串来编译，_TEXT宏可以根据是否定义_UNICODE作相应的转换。(_UNICODE宏用于C运行期头文件，而UNICODE宏则用于Windows头文件)2.2 Unicode与ANSI之间转换字符串Windows函数MultiByteToWideChar用于将多字节字符串转换成宽字符串--------3 内核对象系统要创建和操作若干类型的内核对象，比如存取符号对象、 事件对象、文件对象、文件映射对象、I / O 完成端口对象、作业对象、信箱对象、互斥对象、管道对象、进程对象、信标对象、线程对象和等待计时器对象等。这些对象都是通过调用函数来创建的。内核对象的数据结构只能被内核访问。应用程序创建内核对象成功，将返回该对象的句柄，根据句柄和windows内核对象的函数，应用程序可以操作相应的内核对象。跨越进程边界共享内核对象机制，可使多个进程共享单个内核对象。内核对象由内核所拥有，而不是由进程所拥有。所以当进程退出后，如果内核对象的使用用记数不为0，内核就不会撤消该对象。3.1　跨越进程边界共享内核对象文件映射对象使你能够在同一台机器上运行的两个进程之间共享数据块；邮箱和指定的管道使得应用程序能够在连网的不同机器上运行的进程之间发送数据块；互斥对象、信标和事件使得不同进程中的线程能够同步它们的连续运行对象句柄的继承性改变句柄的标志命名对象
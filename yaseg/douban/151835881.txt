24C64 程序

与93C46类似的，24C64也是EEPROM，但不同的是24C64是I2C接口的，容量也要更大些，用来存储较大容量的数据，甚至在某些单片机中可以用作程序存储器。    24C64提供65536个位，它们是以字节方式进行组织的。通过设置不同的地址，可以实现多达8个芯片共享两线总线。它被广泛应用于工业、化工等需要低功耗与低电压的领域。同时，它还提供诸如4.5V~5.5V、2.7V~5.5V、2.5V~5.5V与1.8V~5.5V各种工作电压范围的芯片，从而使其应用更加通用。24C64的引脚定义：           引脚功能详细描述： 引脚名称 功能 A0~A2 地址输入 SDA 串行数据 SCL 串行时钟输入 WP 写保护 24C64的功能框图：            引脚功能描述：串行时钟（SCL）：在SCL的上升沿数据写入芯片中，在下降沿从芯片中读出数据。串行数据（SDA）：SDA用作双向数据传输。这个引脚是漏极开路驱动，需要加上拉电阻。设备地址（A2，A1，A0）：A2~A0是设备地址设置引脚，可以通过接高或接低来设置不同的地址，也可以直接悬空。设置为不同地址时最多可以在同一总线上存在多达8个芯片。当这些引脚悬空时，默认地址为0。写保护（WP）：当此引脚接到GND上时，允许正常的写操作。当WP接到VCC时，所有的写操作都是被禁止的。如果悬空，则WP在内部被拉到GND。24C64的组织方式：    24C64在内部被组织为256个页，每个页32个字节。可以按字节来进行操作，地址为13位。24C64的操作方法：    24C64是采用I2C接口来进行数据传输的，在这里不再介绍I2C接口数据传输的相关内容，具体的I2C总线协议在相关章节有详细讲解，敬请翻阅。下面只针对于24C64的操作方法进行讲解。    1）设备寻址       在开始条件使芯片使能后，需要给其写入一个8位的设备地址码，以使某一芯片被命中。在地址码的开头有两个“10”序列，共4位，然后是3位 的地址，最后是1位的读写标识位。具体的地址码结构如下：                            24C64使用3个设备地址位A2、A1、A0使多达8个芯片同时存在于一条总线上。这个地址码被每一个芯片与自身设置的地址相比较。       第8位是读／写操作选择位。如果是1的话，一个读操作将被初始化，而如果是0的话，则一个写操作将被初始化。    2）写操作       1.任意字节写：在进行写操作时，在设备地址与回复后，需要写入两个8位地址。在收到地址后，芯片会返回一个低电平，然后就可以写入一个8位数据。在收到这个8位数据后，芯片会返回一个低电平，此时应产生一个停止条件。芯片开始自身的读入过程。在读入过程中，所有的数据输入都是无效的，芯片也不会给予回复字节写操作的时序图如下：             字节写的程序：void AT24C64_W(void *mcu_address,unsigned int AT24C64_address,unsigned int count) { while(count--) { I2C_Start(); /*I2C_Send_Byte( 0xa0 + AT24C64_address /256 *2);*/ /* 24C16 USE */ I2C_Send_Byte(0xa0); I2C_Send_Byte(AT24C64_address/256); I2C_Send_Byte(AT24C64_address%256); I2C_Send_Byte(*(unsigned char*)mcu_address); I2C_Stop(); Delay_N_mS(10); /* waiting for write cycle to be completed */ ((unsigned char*)mcu_address)++; AT24C64_address++; } }        以上程序通过使用字节写实现数据连续写入。       2.页写：24C64也是支持页写的。        页写的初始化与字节写是相同的，但是在第一个字节被写进去以后并不产生停止条件，而是可以继续写入31个字节。在每一个字节写入后芯片会返回低电平。最后应产生一个停止条件以终止页写操作。        内部数据地址的低5位在每接收一个字节后自增，而高位不会自增，保持该页在存储器中的地址。如果有超过32个字节被写入，则页地址会回滚到页头，覆盖前面的数据。        页写的时序图如下：     页写的程序：void AT24C64_WP(void *mcu_address,unsigned int AT24C64_address,unsigned int count) { I2C_Start(); I2C_Send_Byte(0xa0); I2C_Send_Byte(AT24C64_address/256); I2C_Send_Byte(AT24C64_address%256); while(count--) {    I2C_Send_Byte(*(unsigned char*)mcu_address);    Delay_N_mS(10); /* waiting for write cycle to be completed */    ((unsigned char*)mcu_address)++; } I2C_Stop(); }3）读操作   读操作的初始化与写操作是相同的，唯一不同的是读／写选择位要置为1。读操作有三种：当前地址读、字节读、序列读。   1.当前地址读：    芯片内部地址计数器记录了最后一次读或写操作后的地址（地址自动加1），这个地址只要芯片电源供给正常就一直有效。在读操作中，当地址到达最后一个地址（最后一个页的最后一个字节）后会自动“回滚”到最开始的位置（第一个页的第一个字节）。而在写操作中，“回滚”则是从当前页的最后一个字节转到该页的第一个字节。当选择位置1后的设备地址码写入芯片，并回应后，当前地址上的数据将会串行输出。此时，单片机应产生一个停止条件。当前地址读的时序图如下：       当前地址读的程序：unsigned char AT24C64_RC() { unsigned char temp; I2C_Start(); I2C_Send_Byte(0xa1); temp= I2C_Receive_Byte(); I2C_Nack(); I2C_Stop(); return temp;}       2.任意字节读：        任意字节读需要写入一个地址。当设备地址码与数据地址码写入芯片并得到了回应后，此时单片机必须再产生一个开始条件，随后的操作就与当前地址读相同了。        任意字节读的时序图如下：任意字节读的的程序：void AT24C64_R(void *mcu_address,unsigned int AT24C64_address,unsigned int count) { while(count--) { I2C_Start(); I2C_Send_Byte(0xa0); I2C_Send_Byte(AT24C64_address/256); I2C_Send_Byte(AT24C64_address%256); I2C_Start(); I2C_Send_Byte(0xa1); *(unsigned char*)mcu_address=I2C_Receive_Byte(); I2C_Nack(); I2C_Stop(); ((unsigned char*)mcu_address)++; AT24C64_address++; } }以上程序采用字节读的方式实现从某一地址开始读取count个字节。   3.序列读    序列读的初始化与当前字节读与任意字节读相同。在单片机收到一个字节后，都要产生一个回应。然后内部地址会自增并可以继续输出数据。当地址到达尽头时，它会自动“回滚”，而序列读操作会继续。当单片机不再产生回应而产生停止条件时，序列读操作终止。    序列读的时序图：序列读的程序：void AT24C64_RS(void *mcu_address,unsigned int count) { I2C_Start(); I2C_Send_Byte(0xa1); counter--;while(count--) { *(unsigned char*)mcu_address=I2C_Receive_Byte();    I2C_Ack(); ((unsigned char*)mcu_address)++; AT24C64_address++; } *(unsigned char*)mcu_address=I2C_Receive_Byte(); I2C_Nack(); I2C_Stop(); }以上程序用序列读来实现从当前地址开始读取count个字节。备注： 数码管和主函数部分纯属调试，实际引用函数为      写一个字节：writedata_24c64(uchar addH,uchar addL,uchar data_24c64)      读一个字节：readdata_24c64(uchar addH,uchar addL)   写多个字节（建立数组）：write_m_data_24c64(uchar addH,uchar addL,uchar *m_data_24c64,uchar n)   读多个字节（用数组接受）：read_m_data_24c64(uchar addH,uchar addL,uchar n)     注意24c64要写入16位地址，其他类似芯片不一定适用，     要注意看数据手册 PS:速度没被榨干~~     *********************************************/#include <REGX52.H>#define uint unsigned int#define uchar unsigned char/********************24c64定义*********************/sbit sda_24c64 = P0^5; //24c64定义数据线sbit scl_24c64 = P0^4; //24c64定义时钟线/*********************************************/uchar m_data_to_24c64[] = {0x01,0x08,0x0b,0x04,0x05,0x06};uchar m_data_from_24c64[32] ;//接受数组/****************数码管显示部分***********************/sbit sda = P0^2; //164定义数据线sbit scl = P0^3; //164定义时钟线code char led_code1[19]={0x11,0xd7,0x32,0x92,0xd4,     // 0,1,2,3,4 实验板                        0x98,0x18,0xd3,0x10,0x90,     // 5,6,7,8,9       0x50,0x1c,0x39,0x16,0x38,0x78,   // a,b,c,d,e,f       0xfe,0xef,0xff};//“-” , “.” , “ "void shifta( uchar b)//显示一个数（无小数点）{    uchar i;    b=led_code1[b];    scl=0;    for(i=0; i<8; i++)      {         if(b&0x80)           sda=1;         else            sda=0;         scl=1;       scl=0;         b<<=1;        }}/*******************************************/void Delay_xus(uint i)//(16+9*i)us(51){    while(i--);}void Delay_100us()//(16+9*i)us(51){    uchar i = 14;while(i--);}void Delay_100ms()//(16+9*i)us(51){    uchar i;uint j = 1000;for(;j>0;j--){     i = 14;   while(i--);}}/***************************************/void start_24c64(){    sda_24c64 = 1;scl_24c64 = 1;Delay_xus(1); //也可不用延时，怕你单片机快；sda_24c64 = 0;Delay_xus(1); scl_24c64 = 0;//控制时钟线，防止数据误入               // I2C总线空闲时，sda、scl为高电平 }void stop_24c64(){    sda_24c64 = 0;scl_24c64 = 1;Delay_xus(1);sda_24c64 = 1;Delay_xus(1);scl_24c64 = 0;}void ask_24c64() //写数据应答，第九个脉冲sda_24c64为低，则24c64成功接受数据{    uchar k=30;scl_24c64 = 0;scl_24c64 = 1;Delay_xus(1);while(sda_24c64&&k--);//结合写数据发第九个脉冲，检查应答位，若无应答，一定时间后退出scl_24c64 = 0;}void writebyte_24c64(uchar data_to_24c64)//写入数据{    uchar i;scl_24c64 = 0;for(i=0;i<8;i++){     if(data_to_24c64&0x80)   {      sda_24c64 = 1;         }   else    {      sda_24c64 = 0;   }     scl_24c64 = 1;   //时钟线低变高，发数据   Delay_xus(1);   scl_24c64 = 0;   data_to_24c64<<=1;}ask_24c64();}uchar readbyte_24c64(uchar ack) //ack应答位，ack=1，MCU不应答（不继续接受数据）{         //ack=0，MCU应答，继续接受数据    uchar i,data_from_24c64;scl_24c64 = 0;for(i=0;i<8;i++){     data_from_24c64<<=1;   scl_24c64 = 1;   Delay_xus(1);   data_from_24c64 |= sda_24c64;   Delay_xus(1);   scl_24c64 = 0;}sda_24c64 = ack;scl_24c64 = 1;scl_24c64 = 0;sda_24c64 = 1;return data_from_24c64;}void write_o_data_24c64(uchar addH,uchar addL,uchar data_24c64)//写入单个数据{    start_24c64();writebyte_24c64(0xa0);//写指令writebyte_24c64(addH);//写高位地址writebyte_24c64(addL);//写低位地址writebyte_24c64(data_24c64);//写储存数据stop_24c64();}uchar read_o_data_24c64(uchar addH,uchar addL) //读出单个数据{    uchar temp;start_24c64();writebyte_24c64(0xa0);//写写指令writebyte_24c64(addH);//写高位地址writebyte_24c64(addL);//写低位地址(实际上是调24c64地址指针到要读取的数据的地址)    stop_24c64();start_24c64();writebyte_24c64(0xa1);//写读指令temp = readbyte_24c64(1);stop_24c64();return temp;}void write_m_data_24c64(uchar addH,uchar addL,uchar *m_data_24c64,uchar n) //从某地址开始连续多字节写入{    uchar i;start_24c64();writebyte_24c64(0xa0);//写指令writebyte_24c64(addH);//写高位地址writebyte_24c64(addL);//写低位地址if(n>32) //每页最多32字节{     n = 32;}for(i=0;i<n;i++){     writebyte_24c64(*(m_data_24c64++));//写储存数据   Delay_xus(1);}stop_24c64();}void read_m_data_24c64(uchar addH,uchar addL,uchar n)//从某地址开始连续读取n个数据{    uchar i;if(n>32) //n不能大于32，会从头覆盖字节{     n=32;}start_24c64();writebyte_24c64(0xa0);//写写指令writebyte_24c64(addH);//写高位地址writebyte_24c64(addL);//写低位地址(实际上是调24c64地址指针到要读取的数据的地址)    stop_24c64();start_24c64();writebyte_24c64(0xa1);//写读指令for(i=0;i<n;i++)   //读n个字节数据{        m_data_from_24c64[i] = readbyte_24c64(0);}stop_24c64();}void main(){    uchar i,ge,shi,bai;//write_o_data_24c64(0x0f,0x0f,0x80);write_m_data_24c64(0x00,0x00,m_data_to_24c64,6);Delay_100ms();//read_m_data_24c64(0x00,0x00,6);i = read_o_data_24c64(0x00,0x01);//i = m_data_from_24c64[5];bai=i/100;shi=i%100/10;ge=i%10;shifta(0);shifta(ge);shifta(shi);shifta(bai);while(1);}